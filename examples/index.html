<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>simple Javascript WebP decoding demo, using Web-Assembly (WASM)</title>
  <script src="libwebp.js"></script>
  <script type="text/javascript">

    'use strict';
async function encode(raw_data, width, height) {
  const Module = await LIBWEBP();
  const wpEncode = Module.cwrap('wpEncode', 'number', ['number', 'number', 'number', 'number', 'number', 'number']);
  const WebPFree = Module.cwrap('WebPFree', null, ['number']);
  const start = new Date();
  const encoded_data_size_ptr = Module._malloc(4);
  const raw_data_size = raw_data.length * raw_data.BYTES_PER_ELEMENT;
  const raw_data_ptr = Module._malloc(raw_data_size);
  console.log(raw_data_size);

  // Copy data to Emscripten heap (directly accessed from Module.HEAPU8)
  const dataHeap = new Uint8Array(Module.HEAPU8.buffer, raw_data_ptr, raw_data_size);
  dataHeap.set(new Uint8Array(raw_data.buffer));

  const encoded_data_ptr = wpEncode(dataHeap.byteOffset, width, height, 4, 90, encoded_data_size_ptr);
  const end = new Date();
  const encoded_data_size = Module.getValue(encoded_data_size_ptr, 'i32');
  const encoding_time = end - start;
  const result = 'encoding time: ' + encoding_time + ' ms.';  

  const encoded_data = new Uint8ClampedArray(Module.HEAPU8.buffer, encoded_data_ptr, encoded_data_size);

  Module._free(encoded_data_size_ptr);
  WebPFree(encoded_data_ptr);

  var speed_result = document.getElementById('timing');
  if (speed_result != null) {
    speed_result.innerHTML = '<p>'+ result + '</p>';
  }

  downloadBinaryFile("test.webp", encoded_data);
}

async function rescale(image, width, height) {
  const Module = await LIBWEBP();
  const wpRescale = Module.cwrap('wpRescale', 'number', ['array', 'number', 'number', 'number', 'number', 'number']);
  const WebPFree = Module.cwrap('WebPFree', null, ['number']);

  const raw_data_size = image.data.length * image.data.BYTES_PER_ELEMENT;
  const raw_data_ptr = Module._malloc(raw_data_size);
  const raw_data_heap = new Uint8Array(Module.HEAPU8.buffer, raw_data_ptr, raw_data_size);
  console.log(image.data.BYTES_PER_ELEMENT);
  console.log(image.data.length);
  console.log(image.data.buffer);
  console.log(raw_data_heap);
  console.log(image.data);
  console.log(raw_data_size);

  raw_data_heap.set(new Uint8Array(image.data.buffer));

  const raw_rescaled_data_ptr = wpRescale(raw_data_heap.byteOffset, image.width, image.height, 4, width, height)
  const raw_rescaled_data = new Uint8ClampedArray(Module.HEAPU8.buffer, raw_rescaled_data_ptr, width * height * 4);

  return {
    data: raw_rescaled_data, 
    width: width, 
    height: height
  };
}

async function rescaleFile(filename, width, height) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', filename);
  xhr.responseType = 'arraybuffer';
  xhr.onreadystatechange = async function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      const webp_data = new Uint8Array(xhr.response);
      const image = await decode(webp_data);
      console.log('WHAT!!!', image.data.buffer);
      const image_rescale = await rescale(image, width, height );
      console.log(image_rescale);

      writeImagePNG(image_rescale.data, image_rescale.width, image_rescale.height);
      writeImagePNG(image.data, image.width, image.height);
    }
  };
  xhr.send();
}

async function decode(webp_data) {
  var result = "WASM module not finished loading! Please retry";
  var decoded_data = {data: new Uint8ClampedArray([]), width: -1, height: -1};
  const Module = await LIBWEBP();

      // wrapper for the function decoding a WebP into a canvas object
      const wpDecode = Module.cwrap('wpDecode', 'number', ['array', 'number', 'number']);
    const wpGetWidth = Module.cwrap('wpGetWidth', 'number', ['array', 'number']);
    const wpGetHeight = Module.cwrap('wpGetHeight', 'number', ['array', 'number']);
    const wpGetEncoderVersion = Module.cwrap('wpGetEncoderVersion', 'number', []);
    const wpGetDecoderVersion = Module.cwrap('wpGetDecoderVersion', 'number', []);
    const width = wpGetWidth(webp_data, webp_data.length);
    const height = wpGetHeight(webp_data, webp_data.length);  
    const enc_v = wpGetEncoderVersion();  
    const dec_v = wpGetDecoderVersion();  

    console.log("Dimensions", width, height);
    console.log("Libreary Versions", enc_v, dec_v);

    const decoded_data_ptr = Module._malloc(width * height * 4);
    const start = new Date();
    const dec_res = wpDecode(webp_data, webp_data.length, decoded_data_ptr);
    const end = new Date();
    const decoding_time = end - start;
    result = 'decoding time: ' + decoding_time + ' ms.';    
    decoded_data = {
      data: Uint8ClampedArray.from(new Uint8ClampedArray(Module.HEAPU8.buffer, decoded_data_ptr, width * height * 4)), 
      width: width, 
      height: height
    };
    Module._free(decoded_data_ptr);
  
  // display timing result
  var speed_result = document.getElementById('timing');
  if (speed_result != null) {
    speed_result.innerHTML = '<p>'+ result + '</p>';
  }
  console.log(decoded_data);
  console.log(decoded_data.data.buffer);
  console.log( width * height * 4);

  const a = new Uint8ClampedArray([1, 2, 3, 4, 5, 6]);
  console.log( a);
  console.log( a.buffer);
  
  return decoded_data;
}

function base64( buffer ) {
  if (typeof(buffer) === "string") return window.btoa( buffer );

  var binary = '';
  const bytes = new Uint8Array( buffer );
  const len = bytes.byteLength;
  for (var i = 0; i < len; i++) {
      binary += String.fromCharCode( bytes[ i ] );
  }
  
  return window.btoa( binary );
}

function downloadBinaryFile(filename, data) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:application/octet-stream;base64,' + base64(data));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);
  element.click();

  document.body.removeChild(element);
}

const loadImageGradientData = (width, height) => {
  const data = new Uint8ClampedArray(width * height * 4);

  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      const v = Math.trunc( ( i / height ) * 255);
      data[4 * (i * width + j) + 0] = v;
      data[4 * (i * width + j) + 1] = v;
      data[4 * (i * width + j) + 2] = v;
      data[4 * (i * width + j) + 3] = 255 - v;
    }
  }
  return data;
}

const writeImagePNG = (data, width, height) => {
  const canvas = document.createElement('canvas');
  canvas.style.width = width;
  canvas.style.height = height;
  canvas.width = width;
  canvas.height = height;

  const context = canvas.getContext('2d');
  const image_data = new ImageData(data, width, height);
  context.putImageData(image_data, 0, 0);
  const data_url = canvas.toDataURL("image/png");
  const data_byte_string = window.atob(data_url.split(',')[1]);
  downloadBinaryFile("decoded_image.png", data_byte_string);
};

async function encodeGradient() {
  const width = 2048;
  const height = 2048;
  const raw_data = loadImageGradientData(width, height);
  const encoded_data = await encode(raw_data, width, height);
}

async function decodeFile(filename) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', filename);
  xhr.responseType = 'arraybuffer';
  xhr.onreadystatechange = async function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      const webp_data = new Uint8Array(xhr.response);
      const image = await decode(webp_data);
      writeImagePNG(image.data, image.width, image.height);
    }
  };
  xhr.send();
}

  </script>
</head>

<body>
  <p>
    <strong>WebP demo using Web-Assembly</strong> -
  </p>
  <p>
    WASM version of the WebP decoder, using libwebp compiled with
    <a href="https://github.com/kripken/emscripten/wiki">Emscripten</a>.
  </p>
  <p id="image_webp">
    <input type="button" value="WebP Decode"
           onclick="decodeFile('./image.webp')">
  </p>
  <p id="image_webp">
    <input type="button" value="WebP Encode"
           onclick="encodeGradient()">
  </p>
  <p id="image_webp">
    <input type="button" value="WebP Rescale"
           onclick="rescaleFile('./1.webp', 100, 100)">
  </p>
  </body>
</html>
