<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>simple Javascript WebP decoding demo, using Web-Assembly (WASM)</title>
  <script type="text/javascript">
    var Module = {
      noInitialRun : true
    };
  </script>
  <script type="text/javascript">

'use strict';


function init() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'libwebp.wasm', true);
  xhr.responseType = 'arraybuffer';
  xhr.onload = function() {
    Module.wasmBinary = xhr.response;
    var script = document.createElement('script');
    script.src = "libwebp.js";
    document.body.appendChild(script);
  };
  xhr.send(null);
}
window.onload = init;

function encode(raw_data, width, height) {
  const wpEncode = Module.cwrap('wpEncode', 'number', ['array', 'number', 'number']);
  const WebPFree = Module.cwrap('WebPFree', null, ['number']);
  const start = new Date();
  const encoded_data_size_ptr = Module._malloc(4);
  const encoded_data_ptr = wpEncode(raw_data, width, height, encoded_data_size_ptr);
  const end = new Date();
  const encoded_data_size = Module.getValue(encoded_data_size_ptr, 'i32');;
  const encoding_time = end - start;
  const result = 'encoding time: ' + encoding_time + ' ms.';  

  const encoded_data = new Uint8ClampedArray(Module.HEAPU8.buffer, encoded_data_ptr, encoded_data_size);

  Module._free(encoded_data_size_ptr);
  WebPFree(encoded_data_ptr);

  var speed_result = document.getElementById('timing');
  if (speed_result != null) {
    speed_result.innerHTML = '<p>'+ result + '</p>';
  }

  downloadBinaryFile("test.webp", encoded_data);
}

function decode(webp_data, canvas_id) {
  var result;
  var decoded_data = {data: new Uint8ClampedArray([]), width: -1, height: -1};
  if (Module["asm"] != undefined) {
    // wrapper for the function decoding a WebP into a canvas object
    const wpDecode = Module.cwrap('wpDecode', 'number', ['array', 'number', 'number']);
    const wpGetWidth = Module.cwrap('wpGetWidth', 'number', ['array', 'number']);
    const wpGetHeight = Module.cwrap('wpGetHeight', 'number', ['array', 'number']);
    const wpGetEncoderVersion = Module.cwrap('wpGetEncoderVersion', 'number', []);
    const wpGetDecoderVersion = Module.cwrap('wpGetDecoderVersion', 'number', []);
    const width = wpGetWidth(webp_data, webp_data.length);
    const height = wpGetHeight(webp_data, webp_data.length);  
    const enc_v = wpGetEncoderVersion();  
    const dec_v = wpGetDecoderVersion();  

    console.log("Dimensions", width, height);
    console.log("Libreary Versions", enc_v, dec_v);

    const decoded_data_ptr = Module._malloc(width * height * 4);
    const start = new Date();
    const dec_res = wpDecode(webp_data, webp_data.length, decoded_data_ptr);
    const end = new Date();
    const decoding_time = end - start;
    result = 'decoding time: ' + decoding_time + ' ms.';    
    decoded_data = {
      data: new Uint8ClampedArray(Module.HEAPU8.buffer, decoded_data_ptr, width * height * 4), 
      width: width, 
      height: height
    };
    Module._free(decoded_data_ptr);
  } else {
    result = "WASM module not finished loading! Please retry";
  }
  // display timing result
  var speed_result = document.getElementById('timing');
  if (speed_result != null) {
    speed_result.innerHTML = '<p>'+ result + '</p>';
  }
  return decoded_data;
}

function base64( buffer ) {
  if (typeof(buffer) === "string") return window.btoa( buffer );

  var binary = '';
  const bytes = new Uint8Array( buffer );
  const len = bytes.byteLength;
  for (var i = 0; i < len; i++) {
      binary += String.fromCharCode( bytes[ i ] );
  }
  
  return window.btoa( binary );
}

function downloadBinaryFile(filename, data) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:application/octet-stream;base64,' + base64(data));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);
  element.click();

  document.body.removeChild(element);
}

const loadImageGradientData = (width, height) => {
  const data = new Uint8ClampedArray(width * height * 4);

  for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
      const v = Math.trunc( ( i / height ) * 255);
      data[4 * (i * width + j) + 0] = v;
      data[4 * (i * width + j) + 1] = v;
      data[4 * (i * width + j) + 2] = v;
      data[4 * (i * width + j) + 3] = 255 - v;
    }
  }
  return data;
}

const writeImagePNG = (data, width, height) => {
  const canvas = document.createElement('canvas');
  canvas.style.width = width;
  canvas.style.height = height;
  canvas.width = width;
  canvas.height = height;

  const context = canvas.getContext('2d');
  const image_data = new ImageData(data, width, height);
  context.putImageData(image_data, 0, 0);
  const data_url = canvas.toDataURL("image/png");
  const data_byte_string = window.atob(data_url.split(',')[1]);
  downloadBinaryFile("decoded_image.png", data_byte_string);
};

function encodeGradient() {
  const width = 1024;
  const height = 1024;
  const raw_data = loadImageGradientData(width, height);
  const encoded_data = encode(raw_data, width, height);
}

function decodeFile(filename) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', filename);
  xhr.responseType = 'arraybuffer';
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      const webp_data = new Uint8Array(xhr.response);
      const image = decode(webp_data);
      writeImagePNG(image.data, image.width, image.height);
    }
  };
  xhr.send();
}

  </script>
</head>

<body>
  <p>
    <strong>WebP demo using Web-Assembly</strong> -
  </p>
  <p>
    WASM version of the WebP decoder, using libwebp compiled with
    <a href="https://github.com/kripken/emscripten/wiki">Emscripten</a>.
  </p>
  <p id="image_webp">
    <input type="button" value="WebP Decode"
           onclick="decodeFile('./image.webp')">
  </p>
  <p id="image_webp">
    <input type="button" value="WebP Encode"
           onclick="encodeGradient()">
  </p>
  </body>
</html>
